{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Spades_K","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"post_name","slug":"post-name","date":"2020-05-20T05:41:30.000Z","updated":"2020-05-20T05:41:30.411Z","comments":true,"path":"2020/05/20/post-name/","link":"","permalink":"http://yoursite.com/2020/05/20/post-name/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"4G5G互操作-重选","slug":"4G5G互操作-重选","date":"2020-05-20T04:40:26.000Z","updated":"2020-05-20T08:06:42.347Z","comments":true,"path":"2020/05/20/4G5G互操作-重选/","link":"","permalink":"http://yoursite.com/2020/05/20/4G5G%E4%BA%92%E6%93%8D%E4%BD%9C-%E9%87%8D%E9%80%89/","excerpt":"","text":"RRC的3种状态: RRC_CONNECTED: 当一个RRC连接已经建立，则UE处于RRC_CONNECTED态（连接态）。 RRC_INACTIVE: 如果UE连接到5GC，当RRC连接被挂起时，则UE处于RRC_INACTIVE态。 RRC_IDLE态： 以上情况都不是，则UE处于RRC_IDLE态。 RRC_IDLE态下的移动性，是基于UE控制的移动性,UE会执行邻区测量和小区选择重选","categories":[],"tags":[]},{"title":"开篇","slug":"开篇","date":"2020-05-12T11:55:24.000Z","updated":"2020-05-17T15:41:15.385Z","comments":true,"path":"2020/05/12/开篇/","link":"","permalink":"http://yoursite.com/2020/05/12/%E5%BC%80%E7%AF%87/","excerpt":"","text":"保安三问 我是谁？ 我从哪来？ 我要到那里去?","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-05-12T11:41:11.849Z","updated":"2020-05-12T11:41:11.849Z","comments":true,"path":"2020/05/12/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Python习题整理-持续更新","slug":"Python习题整理-持续更新","date":"2020-05-10T08:37:25.755Z","updated":"2020-05-17T15:02:23.541Z","comments":true,"path":"2020/05/10/Python习题整理-持续更新/","link":"","permalink":"http://yoursite.com/2020/05/10/Python%E4%B9%A0%E9%A2%98%E6%95%B4%E7%90%86-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","excerpt":"","text":"一行代码实现1-100之间求和 1sum(range(1, 101)) 如何在一个 函数内部修改全局变量利用global修改全局变量 12345678910&gt;&gt;&gt; a = 5&gt;&gt;&gt; def func():... global a... a = 6...&gt;&gt;&gt; print(f'调用函数前a的原始值&#123;a&#125;')调用函数前a的原始值5&gt;&gt;&gt; func()&gt;&gt;&gt; print(f'调用函数后a的值&#123;a&#125;')调用函数后a的值6 列出5个Python标准库 tkinter : GUI相关 os:与操作系统相关联的 math:数学运算 datetime:处理时间日期 re:正则匹配 - 字典如何删除键？如何合并两个字典？ 删除键用del 1234&gt;&gt;&gt; ditc1 = &#123;'name':'Jack', 'age':18&#125;&gt;&gt;&gt; del ditc1['age']&gt;&gt;&gt; ditc1&#123;'name': 'Jack'&#125; 合并两个字典用update 12345678&gt;&gt;&gt; ditc1 = &#123;'name':'Jack', 'age':18&#125;&gt;&gt;&gt; del ditc1['age']&gt;&gt;&gt; ditc1&#123;'name': 'Jack'&#125;&gt;&gt;&gt; dict2 = &#123;'tel': 1234567&#125;&gt;&gt;&gt; ditc1.update(dict2)&gt;&gt;&gt; ditc1&#123;'name': 'Jack', 'tel': 1234567&#125; Python 的GIL 概念GIL 是Python全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁，即GIL）。使该进程内其他的线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍然是有先后顺序的，并不是同时进行。多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大。 进程与线程的理解进程和线程都是一个时间段的描述，是CPU工作时间段的描述。进程是包含上下文切换的程序执行时间总和，程序执行时间总和=CPU加载上下文+CPU执行+CPU保存上下文进程的颗粒度太大，每次都要有上下文的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU ，CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的，这里的a，b，c就是线程。也就是说线程是共享了进程的上下文环境，的更为细小的 CPU 时间段。 写一种Python对列表去重的方法先通过集合去重，再转换为列表 12345678910&gt;&gt;&gt; list1 = [1,1,2,2,3,4]&gt;&gt;&gt; set_list1 = set(list1)&gt;&gt;&gt; set_list1&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; list_tans = [x for x in set_list1] # 列表推导式&gt;&gt;&gt; list_tans[1, 2, 3, 4]&gt;&gt;&gt; list_trans2 = list(set_list1) ##方法二 直接用list()方法将set转换成list&gt;&gt;&gt; list_trans2[1, 2, 3, 4] func(*args, **kwargs)中的*args和**kwargs是什么意思？*args和**kwargs主要用于函数定义，可以将不定数量的参数传递给一个函数。不定数量即预先不知道函数使用者会传递多少个参数给函数。所以在这两个场景下，需要使用这两种参数。 *args 用来将参数打包成tuple给函数体调用; **kwargs 打包关键字参数成dict给函数体调用。 12345&gt;&gt;&gt; def func1(*args):... print(args, type(args))...&gt;&gt;&gt; func1(1, 2, 3)(1, 2, 3) &lt;class 'tuple'&gt; 12345&gt;&gt;&gt; def func2(**kwargs):... print(kwargs, type(kwargs))...&gt;&gt;&gt; func2(a=1, b=2, c=3)&#123;'a': 1, 'b': 2, 'c': 3&#125; &lt;class 'dict'&gt; python2和python3中range(100)的区别python2返回列表；python3返回迭代器，节约内存。 一句话解释什么样的语言能够使用装饰器函数可以作为参数传递的语言，可以使用装饰器。 python内建的数据类型有哪些？int, bool, str, list, tuple, dict Python中断言方法举例assert()方法，断言成功，则程序 继续执行，断言失败则程序报错。 123456&gt;&gt;&gt; a = 3&gt;&gt;&gt; assert(a&gt;1) # 断言成功，程序继续执行&gt;&gt;&gt; assert(a&gt;7) # 断言失败，程序报错。Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AssertionError Python虚拟环境在使用Python语言的时候,经常使用pip来安装第三方包,由于pip的特性,每个包在系统中只能安装一个版本,但不同的项目可能需要不同版本的第三方包,Python的解决方案就是虚拟环境.顾名思义,虚拟环境就是虚拟出来的一个隔离的Python环境,每个项目都可以有自己的虚拟环境,使用pip安装各自的第三方包,不同项目之间也不会存在冲突,创建虚拟环境需要一些工具. Windows系统：依次pip安装virtualenv，virtualenvwrapper-win,修改系统变量,这个安装完后，GitBash中执行mkvirtualenv 虚拟环境名 总是提示找不到命令，cmd可以。 Linux系统:安装virtualenv,virtualenvwrapper，配置~/.bashrc文件 使用pip工具查看当前已安装的Python扩展库的命令？pip list 查看变量类型的Python内置函数？ 123a = 123type(a)&lt;class 'int'&gt; 查看变量内存地址的Python内置函数？id() 3 &amp; 6的值为2 &amp;为按位与运算符， 3 &amp; 6即0011与0110按位与运算","categories":[],"tags":[]}],"categories":[],"tags":[]}